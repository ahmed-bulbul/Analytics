-- Migration to transform shops table into a proper dimension table
-- with support for multiple e-commerce platforms (Shopify, WooCommerce, Magento)

-- Step 1: Add platform_type and other dimension fields to shops table
ALTER TABLE shops ADD COLUMN IF NOT EXISTS platform_type VARCHAR(20);
ALTER TABLE shops ADD COLUMN IF NOT EXISTS platform_shop_id TEXT;
ALTER TABLE shops ADD COLUMN IF NOT EXISTS shop_name TEXT;
ALTER TABLE shops ADD COLUMN IF NOT EXISTS shop_owner_name TEXT;
ALTER TABLE shops ADD COLUMN IF NOT EXISTS shop_owner_email TEXT;
ALTER TABLE shops ADD COLUMN IF NOT EXISTS country_code VARCHAR(2);
ALTER TABLE shops ADD COLUMN IF NOT EXISTS shop_plan_name TEXT;
ALTER TABLE shops ADD COLUMN IF NOT EXISTS is_active BOOLEAN;

-- Step 2: Update existing data to include platform information
UPDATE shops 
SET 
  platform_type = 'shopify',
  platform_shop_id = shop_domain,
  shop_name = COALESCE(shop_domain, 'Unknown Shop'),
  is_active = TRUE
WHERE platform_type IS NULL;

-- Step 3: Add NOT NULL constraints after data is populated
ALTER TABLE shops ALTER COLUMN platform_type SET NOT NULL;
ALTER TABLE shops ALTER COLUMN is_active SET NOT NULL;
ALTER TABLE shops ALTER COLUMN platform_type SET DEFAULT 'shopify';
ALTER TABLE shops ALTER COLUMN is_active SET DEFAULT TRUE;


-- Add constraint for platform_type
ALTER TABLE shops DROP CONSTRAINT IF EXISTS shops_platform_type_check;
ALTER TABLE shops ADD CONSTRAINT shops_platform_type_check CHECK (platform_type IN ('shopify', 'woocommerce', 'magento'));

-- Step 4: Create indexes for better performance on dimension queries
CREATE INDEX IF NOT EXISTS idx_shops_platform_type ON shops (platform_type);
CREATE INDEX IF NOT EXISTS idx_shops_is_active ON shops (is_active);
CREATE INDEX IF NOT EXISTS idx_shops_platform_shop_id ON shops (platform_shop_id);

-- Step 5: Create a bridge table for platform-specific credentials
-- This separates authentication concerns from the dimension table
CREATE TABLE IF NOT EXISTS shop_platform_credentials (
  credential_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  shop_id BIGINT NOT NULL,
  platform_type VARCHAR(20) NOT NULL,
  access_token_encrypted TEXT,
  access_token_iv TEXT,
  refresh_token_encrypted TEXT,
  refresh_token_iv TEXT,
  api_key_encrypted TEXT,
  api_secret_encrypted TEXT,
  scopes TEXT,
  credentials_metadata TEXT,
  installed_at TIMESTAMP,
  expires_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  CONSTRAINT fk_shop_creds_shop FOREIGN KEY (shop_id) REFERENCES shops(shop_id) ON DELETE CASCADE,
  CONSTRAINT uk_shop_platform UNIQUE (shop_id, platform_type)
);

CREATE INDEX IF NOT EXISTS idx_shop_platform_creds_shop ON shop_platform_credentials (shop_id);
CREATE INDEX IF NOT EXISTS idx_shop_platform_creds_platform ON shop_platform_credentials (platform_type);

-- Step 6: Migrate existing Shopify credentials to new table (H2 compatible)
MERGE INTO shop_platform_credentials 
  USING (
    SELECT 
      shop_id,
      'shopify' as platform_type,
      shopify_access_token_encrypted,
      shopify_access_token_iv,
      shopify_scopes,
      shopify_installed_at,
      NOW() as created_at,
      NOW() as updated_at
    FROM shops
    WHERE shopify_access_token_encrypted IS NOT NULL
  ) AS source
  ON shop_platform_credentials.shop_id = source.shop_id 
  AND shop_platform_credentials.platform_type = source.platform_type
  WHEN NOT MATCHED THEN
    INSERT (shop_id, platform_type, access_token_encrypted, access_token_iv, scopes, installed_at, created_at, updated_at)
    VALUES (source.shop_id, source.platform_type, source.shopify_access_token_encrypted, 
            source.shopify_access_token_iv, source.shopify_scopes, source.shopify_installed_at,
            source.created_at, source.updated_at);



-- Note: For PostgreSQL deployments, JSONB type should be used for credentials_metadata
-- Note: COMMENT statements are omitted for H2 compatibility

-- Step 7: Create views for Doris/analytics integration
-- This view provides a clean bridge between operational data and analytics
CREATE OR REPLACE VIEW v_shop_dimension AS
SELECT 
  s.shop_id,
  s.shop_domain,
  s.platform_type,
  s.platform_shop_id,
  s.shop_name,
  s.shop_owner_name,
  s.shop_owner_email,
  s.currency,
  s.timezone,
  s.country_code,
  s.shop_plan_name,
  s.is_active,
  s.created_at,
  s.updated_at,
  s.deleted_at,
  CASE WHEN s.deleted_at IS NULL THEN TRUE ELSE FALSE END as is_current
FROM shops s;

-- Step 8: Create platform-agnostic order source view
-- This helps map different platform order structures to a common format
CREATE OR REPLACE VIEW v_order_bridge AS
SELECT 
  fo.shop_id,
  s.platform_type,
  fo.order_gid as source_order_id,
  fo.order_name as order_display_name,
  fo.created_at,
  fo.processed_at,
  fo.updated_at,
  fo.cancelled_at,
  fo.financial_status,
  fo.customer_gid as source_customer_id,
  fo.gross_total,
  fo.gross_tax,
  fo.gross_shipping,
  fo.net_sales,
  fo.is_new_customer
FROM fact_orders fo
JOIN shops s ON fo.shop_id = s.shop_id;

-- Step 9: Create customer dimension view for analytics
CREATE OR REPLACE VIEW v_customer_dimension AS
SELECT 
  dc.shop_id,
  s.platform_type,
  dc.customer_gid as source_customer_id,
  dc.email,
  dc.email_hash,
  dc.created_at,
  dc.updated_at,
  dc.first_order_processed_at,
  dc.last_order_processed_at,
  CASE WHEN dc.email IS NOT NULL THEN TRUE ELSE FALSE END as has_email
FROM dim_customers dc
JOIN shops s ON dc.shop_id = s.shop_id;

